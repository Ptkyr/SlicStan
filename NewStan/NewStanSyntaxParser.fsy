%{
open NewStanSyntax 
%}   

%start start 

%token <int> INT
%token <float> REAL  
%token <string> IDE   
%token <string> FUNIDE   

%token DATA INTTYPE REALTYPE  
%token VECTOR MATRIX
%token EQ SIM PLUS MINUS MULT DIV
%token ELMULT ELDIV
%token DEF RET 
%token LBRACE RBRACE
%token LEFT RIGHT  
%token ALEFT ARIGHT  
%token COMMA SEMICOLON
%left PLUS 
%left MINUS
%left MULT 
%left DIV
%left NEG
%token EOF 
%type <NewStanSyntax.NewStanProg> start   
  
%%   
  
start: prog { $1 }

prog:
  | defs statement_seq { $1, $2 }
  | statement_seq { [], $1 }
  | defs { $1, Skip }  


defs:
  | DEF deff defs { $2 :: $3 }
  | DEF deff { [$2] }


deff:
  | IDE LEFT args RIGHT LBRACE statement_seq RET exp SEMICOLON RBRACE { FunE($1, $3, $6, $8) }
  | IDE LEFT RIGHT LBRACE statement_seq RET exp SEMICOLON RBRACE { FunE($1, [], $5, $7) }
  | IDE LEFT args RIGHT LBRACE statement_seq RET SIM dist SEMICOLON RBRACE { FunD($1, $3, $6, $9) }
  | IDE LEFT RIGHT LBRACE statement_seq RET SIM dist SEMICOLON RBRACE { FunD($1, [], $5, $8) }
  | IDE LEFT args RIGHT LBRACE statement_seq RBRACE{ FunV($1, $3, $6, ()) }
  | IDE LEFT RIGHT LBRACE statement_seq RBRACE{ FunV($1, [], $5, ()) }

args:
  | arg COMMA args { $1 :: $3 }
  | arg { [$1] }

arg: 
  | tp IDE { ($1, LevelVar (next())), $2 }



statement_seq:
  | DATA tp IDE SEMICOLON statement_seq { DataDecl($2, $3, $5) }
  | DATA tp IDE SIM dist SEMICOLON statement_seq { DataDecl($2, $3, Seq(Sample($3, $5), $7)) }
  | tp IDE SEMICOLON statement_seq { Block((($1, LevelVar (next())), $2), $4) }
  | tp IDE EQ exp SEMICOLON statement_seq { Block((($1, LevelVar (next())), $2), Seq(Assign(I($2), $4), $6)) }
  | tp IDE SIM dist SEMICOLON statement_seq { Block((($1, LevelVar (next())), $2), Seq(Sample($2, $4), $6)) }
  | statement_signle SEMICOLON statement_seq { Seq($1, $3) }
  | statement_signle SEMICOLON { $1 }
  | tp IDE EQ exp SEMICOLON { Block((($1, LevelVar (next())), $2), Assign(I($2), $4)) }
  | tp IDE SIM dist SEMICOLON { Block((($1, LevelVar (next())), $2), Sample($2, $4)) }
  | EOF { Skip }

statement_signle:
  | lhs EQ exp { Assign($1, $3) }
  | IDE SIM dist { Sample($1, $3) }
  | IDE LEFT exps RIGHT { VCall($1, $3) }
  
exp: 
  | REAL { Const($1) }
  | INT  { Const(float $1) }
  | IDE  { Var($1) }
  | ALEFT exps ARIGHT { Arr($2) }
  | IDE ALEFT exp ARIGHT { ArrElExp(Var $1, $3) }
  | LEFT exp RIGHT { $2 }
  | exp ELMULT exp { Prim(".*", [$1; $3])  }
  | exp ELDIV exp { Prim("./", [$1; $3])  }
  | exp MULT exp { Mul($1, $3) }  
  | exp PLUS exp { Plus($1, $3) }  
  | exp MINUS exp { Prim("-", [$1; $3]) }
  | exp DIV exp { Prim("/", [$1; $3]) }
  //| MINUS REAL %prec NEG { Const(-$2) }
  | IDE LEFT exps RIGHT { if (Map.containsKey $1 Primitives) then Prim($1, $3) else ECall($1, $3) }

exps:
  | exp COMMA exps { $1 :: $3 }
  | exp { [$1] }
  | EOF { [] }

lhs:
  | IDE { I($1) }
  | IDE ALEFT exp ARIGHT { A(I $1, $3) }
  
dist:
  | IDE LEFT exps RIGHT { if (Map.containsKey $1 Primitives) then Dist($1, $3) else DCall($1, $3) }

tp: 
  | tp ALEFT IDE ARIGHT {Array($1, SizeVar($3)) }
  | tp ALEFT INT ARIGHT { Array($1, N($3)) }
  | tp ALEFT ARIGHT { Array($1, N(-1)) }
  | VECTOR ALEFT IDE ARIGHT {Vector(SizeVar($3)) }
  | VECTOR ALEFT INT ARIGHT {Vector(N($3))}
  | MATRIX ALEFT IDE COMMA IDE ARIGHT {Matrix(SizeVar($3), SizeVar($5))}
  | MATRIX ALEFT INT COMMA INT ARIGHT {Matrix(N($3), N($5))}
  | VECTOR   { Vector(N(-1)) }
  | MATRIX   { Matrix(N(-1), N(-1)) }
  | REALTYPE { Real }
  | INTTYPE  { Int }

%%
%{
open NewStanSyntax 
%}   

%start start 

%token <int> INT
%token <float> REAL  
%token <string> IDE   
%token <string> FUNIDE   

%token DATA INTTYPE REALTYPE  
%token VECTOR MATRIX
%token EQ SIM PLUS MULT MINUS DIV
%token DEF RET 
%token LBRACE RBRACE
%token LEFT RIGHT  
%token ALEFT ARIGHT  
%token COMMA SEMICOLON
%token EOF 
%type <NewStanSyntax.NewStanProg> start   
  
%%   
  
start: prog { $1 }

prog:
  | defs statement_seq { $1, $2 }
  | statement_seq { [], $1 }
  | defs { $1, Skip }  


defs:
  | DEF deff defs { $2 :: $3 }
  | DEF deff { [$2] }


deff:
  | IDE LEFT args RIGHT LBRACE statement_seq RET exp SEMICOLON RBRACE { FunE($1, $3, $6, $8) }
  | IDE LEFT RIGHT LBRACE statement_seq RET exp SEMICOLON RBRACE { FunE($1, [], $5, $7) }
  | IDE LEFT args RIGHT LBRACE statement_seq RET SIM dist SEMICOLON RBRACE { FunD($1, $3, $6, $9) }
  | IDE LEFT RIGHT LBRACE statement_seq RET SIM dist SEMICOLON RBRACE { FunD($1, [], $5, $8) }
  | IDE LEFT args RIGHT LBRACE statement_seq RBRACE{ FunV($1, $3, $6, ()) }
  | IDE LEFT RIGHT LBRACE statement_seq RBRACE{ FunV($1, [], $5, ()) }

args:
  | arg COMMA args { $1 :: $3 }
  | arg { [$1] }

arg: 
  | tp IDE { ($1, LevelVar (next())), $2 }



statement_seq:
  | DATA tp IDE SEMICOLON statement_seq { DataDecl($2, $3, $5) }
  | DATA tp IDE SIM dist SEMICOLON statement_seq { DataDecl($2, $3, Seq(Sample($3, $5), $7)) }
  | tp IDE SEMICOLON statement_seq { Block((($1, LevelVar (next())), $2), $4) }
  | tp IDE EQ exp SEMICOLON statement_seq { Block((($1, LevelVar (next())), $2), Seq(Assign(I($2), $4), $6)) }
  | tp IDE SIM dist SEMICOLON statement_seq { Block((($1, LevelVar (next())), $2), Seq(Sample($2, $4), $6)) }
  | statement_signle SEMICOLON statement_seq { Seq($1, $3) }
  | statement_signle SEMICOLON { $1 }
  | tp IDE EQ exp SEMICOLON { Block((($1, LevelVar (next())), $2), Assign(I($2), $4)) }
  | tp IDE SIM dist SEMICOLON { Block((($1, LevelVar (next())), $2), Sample($2, $4)) }
  | EOF { Skip }

statement_signle:
  | lhs EQ exp { Assign($1, $3) }
  | IDE SIM dist { Sample($1, $3) }
  | IDE LEFT exps RIGHT { VCall($1, $3) }
  
exp: 
  | REAL { Const($1) }
  | INT  { Const(float $1) }
  | IDE  { Var($1) }
  | ALEFT exps ARIGHT { Arr($2) }
  | IDE ALEFT exp ARIGHT { ArrElExp(Var $1, $3) }
  | LEFT exp RIGHT { $2 }
  | exp PLUS exp { Plus($1, $3) }
  | exp MULT exp { Mul($1, $3) }
  | exp MINUS exp { Prim("-", [$1; $3]) }
  | exp DIV exp { Prim("/", [$1; $3]) }
  | IDE LEFT exps RIGHT { if (Map.containsKey $1 Primitives) then Prim($1, $3) else ECall($1, $3) }

exps:
  | exp COMMA exps { $1 :: $3 }
  | exp { [$1] }
  | EOF { [] }

lhs:
  | IDE { I($1) }
  | IDE ALEFT exp ARIGHT { A(I $1, $3) }
  
dist:
  | IDE LEFT exps RIGHT { if (Map.containsKey $1 Primitives) then Dist($1, $3) else DCall($1, $3) }

tp: 
  | tp ALEFT INT ARIGHT { Array($1, $3) }
  | tp ALEFT ARIGHT { Array($1, -1) }
  | VECTOR ALEFT INT ARIGHT {Vector($3)}
  | MATRIX ALEFT INT COMMA INT ARIGHT {Matrix($3, $5)}
  | VECTOR   {Vector(-1)}
  | MATRIX   {Matrix(-1,-1)}
  | REALTYPE { Real }
  | INTTYPE  { Int }

%%